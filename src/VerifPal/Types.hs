
-- Based on: https://verifpal.com/res/pdf/manual.pdf

module VerifPal.Types where

import Data.Set (Set)
import Data.List.NonEmpty (NonEmpty)
import Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
import Data.Text (Text)

data Model = Model
  { modelAttacker :: Attacker
  , modelParts :: [ModelPart]
  } deriving (Eq, Ord, Show)

data Attacker
  = Active
  | Passive
  deriving (Eq, Ord, Show)

data ModelPart
  = ModelPrincipal Principal
  | ModelMessage Message
  | ModelPhase Phase
  | ModelQueries [Query]
  deriving (Eq, Ord, Show)

data Principal = Principal
  { principalName :: PrincipalName
  , principalKnows :: [(Constant, Knowledge)]
  } deriving (Eq, Ord, Show)

type PrincipalName = Text

data Message = Message
  { messageSender :: PrincipalName
  , messageReceiver :: PrincipalName
  , messageConstants :: [Constant]
  } deriving (Eq, Ord, Show)

newtype Phase = Phase
  { phaseNumber :: Word
  } deriving (Eq, Ord, Show)

data Query = Query
  { queryKind :: QueryKind
  , queryOptions :: Maybe QueryOption
  } deriving (Eq, Ord, Show)

data QueryKind
  = ConfidentialityQuery { confidentialityConstant :: Constant }
  | AuthenticationQuery { authenticationMessage :: Message }
  | FreshnessQuery { freshnessConstant :: Constant }
  | UnlinkabilityQuery { unlinkabilityConstants :: [Constant] }
  | EquivalenceQuery { equivalenceConstants :: [Constant] }
  deriving (Eq, Ord, Show)

data QueryOption = QueryOption { queryOptionMessage :: Message }
  deriving (Eq, Ord, Show)

-- Fundamental types: Constants, primitives, equations

-- Constants:
--  * Immutable, global namespace, can't be assigned to one another.
--  * Constants can only be assigned to primitives or equations.
--
newtype Constant = Constant
  { constantName :: Text
  } deriving (Eq, Ord, Show)

data Knowledge
  = Private   -- ^ Known ahead by principal only
  | Public    -- ^ Known ahead by everyone
  | Generates -- ^ Generated by principal ("ephemeral")
  | Password  -- ^ Alternative to Private, allows the attacker to guess
  | Leaks     -- ^ ?
  | Assignment Expr
  deriving (Eq, Ord, Show)

-- Primitives:
--  * Decompose: Given ENC(k, m) and k, reveal m.
--  * Recompose: Given a, b, reveal x if a, b, _ = SHAMIR_SPLIT(x)
--  * Rewrite: Given DEC(k, ENC(k, m)), rewrite this to m.
--  * Rebuild: Given SHAMIR_JOIN(a, b) where a, b, c = SHAMIR_SPLIT(x),
--             rewrite SHAMIR_JOIN(a, b) to x.

data Expr 
    -- Equations
  = G Expr                                -- G^...
  | (:^:) Constant Expr                   -- a^b
  | EConstant Constant                    -- a
  | EPrimitive Primitive CheckedPrimitive -- ...?
  deriving (Eq, Ord, Show)
 
data Primitive
    -- Core primitives
  = ASSERT Expr Expr  -- ASSERT(a, b): unused
  | CONCAT [Expr]     -- CONCAT(a, b): c
  | SPLIT Expr        -- SPLIT(...CONCAT(a, b)...): a, b

    -- Hashing primitives
  | HASH [Expr]      -- HASH(a, ..., e): x
  | MAC Expr Expr                -- MAC(key, message): hash
  | HKDF Expr Expr Expr  -- HKDF(salt, ikm, info): a, ..., e
  | PW_HASH [Expr]   -- PW_HASH(a, ..., e): x

    -- Encryption primitives
  | ENC Expr Expr  -- ENC(key, plaintext): ciphertext
  | DEC Expr Expr  -- DEC(key, ENC(key, plaintext)): plaintext
  | AEAD_ENC Expr Expr Expr  -- AEAD_ENC(key, plaintext, ad): ciphertext
  | AEAD_DEC Expr Expr Expr  -- AEAD_DEC(key, AEAD_ENC(key, plaintext, ad), ad): plaintext
  | PKE_ENC Expr Expr   -- PKE_ENC(G^key, plaintext): ciphertext
  | PKE_DEC Expr Expr   -- PKE_DEC(key, PKE_ENC(G^key, plaintext)): plaintext

    -- Signature primitives
  | SIGN Expr Expr          -- SIGN(key, message): signature
  | SIGNVERIF Expr Expr Expr   -- SIGNVERIF(G^key, message, SIGN(key, message)): message
  | RINGSIGN Expr Expr Expr Expr  -- RINGSIGN(key_a, G^key_b, G^key_c, message): signature
  | RINGSIGNVERIF Expr Expr Expr Expr Expr  -- RINGSIGNVERIF(G^a, G^b, G^c, m, RINGSIGN(a, G^b, G^c, m)): m
  | BLIND Expr Expr  -- BLIND(k, m): m
  | UNBLIND Expr Expr Expr  -- UNBLIND(k, m, SIGN(a, BLIND(k, m))): SIGN(a, m)

    -- Secret sharing primitives
  | SHAMIR_SPLIT Expr  -- SHAMIR_SPLIT(k): s1, s2, s3
  | SHAMIR_JOIN Expr Expr Expr -- SHAMIR_JOIN(sa, sb): k
  deriving (Eq, Ord, Show)

-- Checked Primitive:  if you add a question mark (?) after one of these
-- primitives, then model execution will abort should AEAD_DEC fail
-- authenticated decryption, or should ASSERT fail to find its two provided
-- inputs equal, or should SIGNVERIF fail to verify the signature against the
-- provided message and public key.
--
-- TODO: Propagate this to the assigned
data CheckedPrimitive
  = HasQuestionMark
  | HasntQuestionMark
  deriving (Eq, Ord, Show)


mkConst :: Text -> Expr
mkConst = EConstant . Constant
